/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => KeyshotsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var isCaret = (sel) => {
  var _a;
  return sel.anchor.ch === ((_a = sel.head) == null ? void 0 : _a.ch) && sel.anchor.line === sel.head.line;
};
var isSelection = (sel) => !isCaret(sel);
var normalizeSelection = (sel) => {
  if (sel.anchor.line == sel.head.line)
    return sel.anchor.ch > sel.head.ch ? { anchor: sel.head, head: sel.anchor } : { anchor: sel.anchor, head: sel.head };
  return sel.anchor.line < sel.head.line ? { anchor: sel.anchor, head: sel.head } : { anchor: sel.head, head: sel.anchor };
};
var selToPos = (sel) => [sel.anchor, sel.head];
var getRangeSel = (editor, sel) => editor.getRange(...selToPos(normalizeSelection(sel)));
var selectionToRange = (range) => {
  return { from: range.anchor, to: range.head };
};
var expandSelection = (editor, sel) => {
  sel = normalizeSelection(sel);
  return {
    anchor: { ch: 0, line: sel.anchor.line },
    head: { ch: editor.getLine(sel.head.line).length, line: sel.head.line }
  };
};
var invertSelection = (sel) => {
  const t = sel.anchor;
  sel.anchor = sel.head;
  sel.head = t;
  return sel;
};
var flipBooleanSetting = (app2, setting) => app2.vault.setConfig(setting, !app2.vault.getConfig(setting));
var replaceSelections = (editor, transformFct) => {
  editor.listSelections().filter(isSelection).forEach((sel) => {
    const { anchor: from, head: to } = normalizeSelection(sel);
    editor.replaceRange(transformFct(editor.getRange(from, to)), from, to);
  });
};
var selectionsProcessor = (editor, arrCallback, fct) => {
  const selections = [];
  (arrCallback !== void 0 ? arrCallback(editor.listSelections()) : editor.listSelections()).forEach((sel, index) => selections.push(fct(sel, index)));
  if (selections.length > 0)
    editor.setSelections(selections);
};
var selectionsEqual = (one, two) => {
  return one.anchor.ch === two.anchor.ch && one.anchor.line === two.anchor.line && one.head.line === two.head.line && one.head.ch === two.head.ch;
};
var convertOneToOtherChars = (editor, first, second) => {
  replaceSelections(editor, (tx) => {
    const [underI, spaceI] = [tx.indexOf(first), tx.indexOf(second)];
    const replaceToUnder = (s) => s.replace(new RegExp(second, "gm"), first);
    const replaceToSpace = (s) => s.replace(new RegExp(first, "gm"), second);
    if (underI !== -1 || spaceI !== -1)
      return tx;
    if (underI === -1)
      return replaceToUnder(tx);
    if (spaceI === -1)
      return replaceToSpace(tx);
    if (underI > spaceI)
      return replaceToUnder(tx);
    return replaceToSpace(tx);
  });
};
function moveLine(editor, direction, border) {
  selectionsProcessor(editor, void 0, (sel) => {
    const normSel = normalizeSelection(sel);
    if (direction === 1 ? normSel.head.line === border : normSel.anchor.line === border)
      return sel;
    const { anchor: from, head: to } = expandSelection(editor, {
      anchor: { line: normSel.anchor.line + (direction === -1 ? direction : 0), ch: normSel.anchor.ch },
      head: { line: normSel.head.line + (direction === 1 ? direction : 0), ch: normSel.head.ch }
    });
    const tx = editor.getRange(from, to);
    if (isCaret(sel))
      editor.replaceRange(tx.split("\n").reverse().join("\n"), from, to);
    else {
      const pieces = [
        tx.split("\n").slice(...direction === 1 ? [-1] : [0, 1])[0],
        tx.split("\n").slice(...direction === 1 ? [void 0, -1] : [1]).join("\n")
      ];
      if (direction === -1)
        pieces.reverse();
      editor.replaceRange(pieces.join("\n"), from, to);
    }
    return {
      anchor: { line: sel.anchor.line + direction, ch: sel.anchor.ch },
      head: { line: sel.head.line + direction, ch: sel.head.ch }
    };
  });
}
function jetBrainsDuplicate(editor) {
  selectionsProcessor(editor, void 0, (sel) => {
    if (isCaret(sel)) {
      const ln = sel.anchor.line;
      const tx = editor.getLine(ln);
      editor.setLine(ln, tx + "\n" + tx);
      return {
        anchor: { line: sel.anchor.line + 1, ch: sel.anchor.ch },
        head: { line: sel.anchor.line + 1, ch: sel.anchor.ch }
      };
    } else {
      const { anchor: from, head: to } = normalizeSelection(sel);
      const tx = editor.getRange(from, to);
      editor.replaceRange(tx, from, from);
      return { anchor: to, head: editor.offsetToPos(editor.posToOffset(to) + tx.length) };
    }
  });
}
function vscodeDuplicate(editor, direction) {
  selectionsProcessor(editor, void 0, (sel) => {
    if (isCaret(sel)) {
      const ln = sel.anchor.line;
      const tx = editor.getLine(ln);
      editor.setLine(ln, tx + "\n" + tx);
      if (direction > 0)
        return {
          anchor: { line: sel.anchor.line + 1, ch: sel.anchor.ch },
          head: { line: sel.anchor.line + 1, ch: sel.anchor.ch }
        };
    } else {
      const { anchor: from, head: to } = normalizeSelection(sel);
      const { anchor: lfrom, head: lto } = expandSelection(editor, normalizeSelection(sel));
      const tx = editor.getRange(lfrom, lto);
      editor.replaceRange(tx + "\n" + tx, lfrom, lto);
      if (direction > 0) {
        return {
          anchor: { ch: sel.anchor.ch, line: sel.anchor.line + (to.line - from.line + 1) },
          head: { ch: sel.head.ch, line: sel.head.line + (to.line - from.line + 1) }
        };
      }
    }
    return sel;
  });
}
function addCarets(editor, direction, border) {
  const newSelections = editor.listSelections();
  const caretSelectsOnly = newSelections.filter((val) => isCaret(val));
  if (caretSelectsOnly.length === 0)
    return;
  const last = caretSelectsOnly[direction > 0 ? caretSelectsOnly.length - 1 : 0];
  if (last.anchor.line === border)
    return;
  newSelections.push({
    anchor: { ch: last.anchor.ch, line: last.anchor.line + direction },
    head: { ch: last.anchor.ch, line: last.anchor.line + direction }
  });
  editor.setSelections(newSelections);
  const scroll = { anchor: { ch: last.anchor.ch, line: last.anchor.line + direction * 2 } };
  editor.scrollIntoView({ from: scroll.anchor, to: scroll.anchor });
}
function insertLine(editor, direction) {
  selectionsProcessor(editor, (s) => s.sort((a, b) => a.anchor.line - b.anchor.line), (sel, index) => {
    const a = (ln) => {
      const tx = [editor.getLine(ln), "\n"];
      if (direction < 0)
        tx.reverse();
      editor.setLine(ln, tx.join(""));
      return {
        anchor: { ch: 0, line: ln + (direction > 0 ? direction : 0) },
        head: { ch: 0, line: ln + (direction > 0 ? direction : 0) }
      };
    };
    if (isCaret(sel))
      return a(sel.anchor.line + index);
    else {
      const { anchor: from, head: to } = normalizeSelection(sel);
      return a((direction > 0 ? to.line : from.line) + index);
    }
  });
}
var convertURI = (editor) => {
  replaceSelections(editor, (s) => {
    try {
      const decoded = decodeURI(s);
      if (decoded === s)
        throw new Error();
      return decoded;
    } catch (e) {
      return encodeURI(s);
    }
  });
};
var titleCase = (s) => s.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase());
function splitSelectedTextOnNewLine(editor) {
  let index = 0;
  selectionsProcessor(editor, (arr) => arr.sort((a, b) => a.anchor.line - b.anchor.line), (sel) => {
    if (isCaret(sel))
      return sel;
    else {
      const { anchor: from, head: to } = normalizeSelection({
        anchor: { ch: sel.anchor.ch, line: sel.anchor.line + index },
        head: { ch: sel.head.ch, line: sel.head.line + index }
      });
      const tx = editor.getRange(from, to);
      editor.replaceRange("\n" + tx + "\n", from, to);
      index += (tx.match(/\n/g) || []).length + 1;
      return {
        anchor: { ch: 0, line: from.line + 1 },
        head: { ch: editor.getLine(to.line + 1).length, line: to.line + 1 }
      };
    }
  });
}
function sortSelectedLines(editor) {
  selectionsProcessor(editor, (arr) => arr.filter(isSelection), (sel) => {
    const { anchor: from, head: to } = expandSelection(editor, normalizeSelection(sel));
    editor.replaceRange(editor.getRange(from, to).split("\n").sort((a, b) => a.localeCompare(b, void 0, { numeric: true, sensitivity: "base" })).join("\n"), from, to);
    return expandSelection(editor, normalizeSelection(sel));
  });
}
var lowestSelection = (selections) => {
  return selections.filter((sel, _i, arr) => normalizeSelection(sel).head.line === Math.max(...arr.map((s) => normalizeSelection(s).head.line))).filter((sel, _i, arr) => normalizeSelection(sel).head.ch === Math.max(...arr.map((s) => normalizeSelection(s).head.ch)))[0];
};
var selectionValuesEqual = (editor, selections, case_sensitive) => {
  return selections.every((val, _i, arr) => {
    const [one, two] = [arr[0], val].map((s) => editor.getRange(...selToPos(normalizeSelection(s))));
    if (!case_sensitive)
      return one.toLowerCase() === two.toLowerCase();
    return one === two;
  });
};
function selectWord(editor, sel) {
  sel = normalizeSelection(sel);
  const txt = editor.getLine(sel.anchor.line);
  const postCh = (txt.substring(sel.anchor.ch).match(/^[\w]+/i) || [""])[0].length;
  const preCh = (txt.substring(0, sel.anchor.ch).match(/[\w]+$/i) || [""])[0].length;
  return {
    anchor: { line: sel.anchor.line, ch: sel.anchor.ch - preCh },
    head: { line: sel.anchor.line, ch: sel.anchor.ch + postCh }
  };
}
function selectWordInstances(editor, case_sensitive) {
  const selections = editor.listSelections();
  let range;
  if (selections.filter(isCaret).length > 0)
    selections.filter(isCaret).forEach((sel, i) => selections[i] = selectWord(editor, sel));
  else if (selections.filter(isSelection).length === selections.length && selectionValuesEqual(editor, selections, case_sensitive)) {
    let { anchor: from, head: to } = normalizeSelection(lowestSelection(selections));
    const tx = !case_sensitive ? editor.getRange(from, to).toLowerCase() : editor.getRange(from, to);
    const match = (!case_sensitive ? editor.getValue().toLowerCase() : editor.getValue()).substring(editor.posToOffset(to)).match(tx);
    if (match !== null) {
      const sel = {
        anchor: editor.offsetToPos(editor.posToOffset(to) + (match.index || 0)),
        head: editor.offsetToPos(editor.posToOffset(to) + (match.index || 0) + tx.length)
      };
      selections.push(sel);
      range = selectionToRange(sel);
    } else {
      let searchText = !case_sensitive ? editor.getValue().toLowerCase() : editor.getValue();
      let shift = 0;
      let match2 = searchText.match(tx);
      while (match2 !== null) {
        const prevTx = (!case_sensitive ? editor.getValue().toLowerCase() : editor.getValue()).substring(0, shift + ((match2 == null ? void 0 : match2.index) || 0));
        const sel = { anchor: editor.offsetToPos(prevTx.length), head: editor.offsetToPos(prevTx.length + tx.length) };
        if (selections.filter((s) => selectionsEqual(sel, s)).length === 0) {
          selections.push(sel);
          range = selectionToRange(sel);
          break;
        } else {
          shift += ((match2 == null ? void 0 : match2.index) || 0) + tx.length;
          searchText = searchText.substring(((match2 == null ? void 0 : match2.index) || 0) + tx.length);
        }
        match2 = searchText.match(tx);
      }
    }
  }
  editor.setSelections(selections);
  if (range !== void 0)
    editor.scrollIntoView(range);
}
function selectAllWordInstances(editor, case_sensitive) {
  const selections = editor.listSelections();
  selections.filter(isCaret).forEach((sel, i) => selections[i] = selectWord(editor, sel));
  if (selections.filter(isSelection).length === selections.length && selectionValuesEqual(editor, selections, case_sensitive)) {
    const tx = getRangeSel(editor, selections[0]);
    Array.from(editor.getValue().matchAll(new RegExp(tx, "g" + (case_sensitive ? "" : "i"))), (v) => v.index || 0).forEach((v) => {
      selections.push({ anchor: { line: 0, ch: v }, head: { line: 0, ch: v + tx.length } });
    });
  } else
    return;
  editor.setSelections(selections);
}
function expandSelections(editor) {
  selectionsProcessor(editor, void 0, (sel) => editor.posToOffset(sel.anchor) <= editor.posToOffset(sel.head) ? expandSelection(editor, sel) : invertSelection(expandSelection(editor, sel)));
}
async function toggleCaseSensitivity(plugin) {
  plugin.settings.case_sensitive = !plugin.settings.case_sensitive;
  const val = plugin.settings.case_sensitive;
  new import_obsidian.Notice(`${val ? "\u{1F512}" : "\u{1F513}"} Keyshots actions are now case ${val ? "" : "in"}sensitive!`);
  await plugin.saveSettings();
}
function splitSelectionsByLines(editor) {
  const selections = [];
  editor.listSelections().forEach((sel) => {
    if (isCaret(sel) || sel.anchor.line === sel.head.line)
      selections.push(sel);
    else {
      const { anchor: from, head: to } = normalizeSelection(sel);
      selections.push({ anchor: from, head: { line: from.line, ch: editor.getLine(from.line).length } });
      for (let i = from.line + 1; i < to.line; i++)
        selections.push({ anchor: { line: i, ch: 0 }, head: { line: i, ch: editor.getLine(i).length } });
      selections.push({ anchor: { line: to.line, ch: 0 }, head: to });
    }
  });
  editor.setSelections(selections);
}
function shuffleSelectedLines(editor, rounds) {
  selectionsProcessor(editor, (arr) => arr.filter(isSelection), (sel) => {
    const { anchor: from, head: to } = expandSelection(editor, normalizeSelection(sel));
    let text = editor.getRange(from, to);
    for (let i = 0; i < rounds; i++)
      text = text.split("\n").sort(() => Math.random() - 0.5).join("\n");
    editor.replaceRange(text, from, to);
    return expandSelection(editor, normalizeSelection(sel));
  });
}
function openKeyshotsSettings(app2) {
  if (app2.setting.activeTab === null)
    app2.setting.open();
  app2.setting.openTabById("keyshots");
}
var DEFAULT_SETTINGS = {
  ide_mappings: "clear",
  keyshot_mappings: true,
  case_sensitive: true,
  shuffle_rounds_amount: 10
};
var hotKey = (key, ...modifiers) => [{ key, modifiers }];
var DEFAULT_MAP = {
  add_carets_down: hotKey("ArrowDown", "Mod", "Alt"),
  add_carets_up: hotKey("ArrowUp", "Mod", "Alt"),
  encode_or_decode_uri: hotKey("U", "Mod", "Alt"),
  insert_line_below: hotKey("Enter", "Shift"),
  insert_line_above: hotKey("Enter", "Ctrl", "Shift"),
  join_selected_lines: hotKey("J", "Mod", "Shift"),
  sort_selected_lines: hotKey("S", "Mod", "Shift"),
  shuffle_selected_lines: hotKey("S", "Mod", "Shift", "Alt"),
  split_selections_by_lines: hotKey("L", "Mod", "Alt"),
  split_selections_on_new_line: hotKey("S", "Alt"),
  select_all_word_instances: hotKey("L", "Mod", "Shift"),
  select_multiple_word_instances: hotKey("D", "Mod"),
  trim_selections: hotKey("T", "Alt"),
  move_line_up: hotKey("ArrowUp", "Alt"),
  move_line_down: hotKey("ArrowDown", "Alt"),
  duplicate_line_up: hotKey("ArrowUp", "Shift", "Alt"),
  duplicate_line_down: hotKey("ArrowDown", "Shift", "Alt"),
  duplicate_selection_or_line: hotKey("D", "Mod", "Alt"),
  expand_line_selections: hotKey("E", "Alt"),
  toggle_case: hotKey("U", "Ctrl", "Shift"),
  toggle_readable_length: hotKey("R", "Mod", "Alt"),
  toggle_line_numbers: hotKey("N", "Mod", "Alt"),
  toggle_inline_title: hotKey("T", "Mod", "Alt"),
  toggle_keyshots_case_sensitivity: hotKey("I", "Mod", "Alt"),
  transform_selections_to_lowercase: hotKey("L", "Alt"),
  transform_selections_to_uppercase: hotKey("U", "Alt"),
  transform_selections_to_titlecase: hotKey("C", "Alt"),
  transform_from_to_snakecase: hotKey("-", "Shift", "Alt"),
  transform_from_to_kebabcase: hotKey("-", "Alt")
};
var KEYSHOTS_MAPS = {
  "clear": {},
  "keyshots": DEFAULT_MAP,
  "vscode": {
    add_carets_down: hotKey("ArrowDown", "Mod", "Alt"),
    add_carets_up: hotKey("ArrowUp", "Mod", "Alt"),
    insert_line_below: hotKey("Enter", "Mod"),
    insert_line_above: hotKey("Enter", "Mod", "Shift"),
    join_selected_lines: hotKey("J", "Mod"),
    select_all_word_instances: hotKey("L", "Mod", "Shift"),
    select_multiple_word_instances: hotKey("D", "Mod"),
    move_line_up: hotKey("ArrowUp", "Alt"),
    move_line_down: hotKey("ArrowDown", "Alt"),
    duplicate_line_up: hotKey("ArrowUp", "Shift", "Alt"),
    duplicate_line_down: hotKey("ArrowDown", "Shift", "Alt"),
    duplicate_selection_or_line: void 0,
    expand_line_selections: hotKey("L", "Mod"),
    toggle_case: void 0
  },
  "jetbrains": {
    insert_line_below: hotKey("Enter", "Shift"),
    insert_line_above: hotKey("Enter", "Mod", "Alt"),
    join_selected_lines: hotKey("J", "Mod", "Shift"),
    select_all_word_instances: hotKey("J", "Mod", "Shift", "Alt"),
    select_multiple_word_instances: hotKey("J", "Alt"),
    move_line_up: hotKey("ArrowUp", "Shift", "Alt"),
    move_line_down: hotKey("ArrowDown", "Shift", "Alt"),
    duplicate_line_down: void 0,
    duplicate_line_up: void 0,
    duplicate_selection_or_line: hotKey("D", "Mod"),
    expand_line_selections: hotKey("W", "Mod"),
    toggle_case: hotKey("U", "Mod", "Shift")
  },
  "visual_studio": {
    add_carets_down: hotKey("ArrowDown", "Shift", "Alt"),
    add_carets_up: hotKey("ArrowUp", "Shift", "Alt"),
    insert_line_below: hotKey("Enter", "Shift"),
    insert_line_above: hotKey("Enter", "Mod"),
    select_all_word_instances: hotKey(";", "Shift", "Alt"),
    select_multiple_word_instances: hotKey(".", "Shift", "Alt"),
    move_line_up: hotKey("ArrowUp", "Alt"),
    move_line_down: hotKey("ArrowDown", "Alt"),
    duplicate_line_down: void 0,
    duplicate_line_up: void 0,
    duplicate_selection_or_line: hotKey("D", "Mod"),
    expand_line_selections: hotKey("=", "Shift", "Alt"),
    transform_selections_to_lowercase: hotKey("U", "Mod"),
    transform_selections_to_uppercase: hotKey("U", "Mod", "Shift"),
    toggle_case: void 0
  }
};
var KeyshotsPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new KeyshotsSettingTab(this.app, this));
    this.loadCommands();
  }
  async loadCommands() {
    if (this.command_ids !== void 0)
      this.command_ids.forEach((cmd) => this.app.commands.removeCommand(cmd));
    const IDS = [];
    const MAP = ["clear", "keyshots"].contains(this.settings.ide_mappings) ? KEYSHOTS_MAPS[this.settings.ide_mappings] : { ...this.settings.keyshot_mappings ? DEFAULT_MAP : {}, ...KEYSHOTS_MAPS[this.settings.ide_mappings] };
    IDS.push(this.addCommand({
      id: "toggle-keyshots-case-sensitivity",
      name: "Toggle Keyshots case sensitivity",
      hotkeys: MAP.toggle_keyshots_case_sensitivity,
      callback: () => toggleCaseSensitivity(this)
    }).id, this.addCommand({
      id: "open-keyshots-settings",
      name: "Open Keyshots settings",
      hotkeys: MAP.open_keyshots_settings,
      callback: () => openKeyshotsSettings(app)
    }).id, this.addCommand({
      id: "toggle-readable-length",
      name: "Toggle readable line length (setting)",
      hotkeys: MAP.toggle_readable_length,
      callback: () => flipBooleanSetting(this.app, "readableLineLength")
    }).id, this.addCommand({
      id: "toggle-line-numbers",
      name: "Toggle line numbers (setting)",
      hotkeys: MAP.toggle_line_numbers,
      callback: () => flipBooleanSetting(this.app, "showLineNumber")
    }).id, this.addCommand({
      id: "toggle-inline-title",
      name: "Toggle inline title (setting)",
      hotkeys: MAP.toggle_inline_title,
      callback: () => flipBooleanSetting(this.app, "showInlineTitle")
    }).id, this.addCommand({
      id: "move-line-up",
      name: "Move line up",
      hotkeys: MAP.move_line_up,
      editorCallback: (editor) => moveLine(editor, -1 /* UP */, 0)
    }).id, this.addCommand({
      id: "move-line-down",
      name: "Move line down",
      hotkeys: MAP.move_line_down,
      editorCallback: (editor) => moveLine(editor, 1 /* DOWN */, editor.lineCount() - 1)
    }).id, this.addCommand({
      id: "add-carets-up",
      name: "Add caret cursor up",
      hotkeys: MAP.add_carets_up,
      editorCallback: (editor) => addCarets(editor, -1 /* UP */, 0)
    }).id, this.addCommand({
      id: "add-carets-down",
      name: "Add caret cursor down",
      hotkeys: MAP.add_carets_down,
      editorCallback: (editor) => addCarets(editor, 1 /* DOWN */, editor.lineCount())
    }).id, this.addCommand({
      id: "duplicate-line-up",
      name: "Duplicate line up (Visual Studio Code)",
      hotkeys: MAP.duplicate_line_up,
      editorCallback: (editor) => vscodeDuplicate(editor, -1 /* UP */)
    }).id, this.addCommand({
      id: "duplicate-line-down",
      name: "Duplicate line down (Visual Studio Code)",
      hotkeys: MAP.duplicate_line_down,
      editorCallback: (editor) => vscodeDuplicate(editor, 1 /* DOWN */)
    }).id, this.addCommand({
      id: "duplicate-selection-or-line",
      name: "Duplicate selection or line (JetBrains IDEs)",
      hotkeys: MAP.duplicate_selection_or_line,
      editorCallback: (editor) => jetBrainsDuplicate(editor)
    }).id, this.addCommand({
      id: "insert-line-above",
      name: "Insert line above",
      hotkeys: MAP.insert_line_above,
      editorCallback: (editor) => insertLine(editor, -1 /* UP */)
    }).id, this.addCommand({
      id: "insert-line-below",
      name: "Insert line below",
      hotkeys: MAP.insert_line_below,
      editorCallback: (editor) => insertLine(editor, 1 /* DOWN */)
    }).id, this.addCommand({
      id: "join-selected-lines",
      name: "Join selected lines",
      hotkeys: MAP.join_selected_lines,
      editorCallback: (editor) => replaceSelections(editor, (s) => s.replace(/\n/g, ""))
    }).id, this.addCommand({
      id: "split-selections-on-new-line",
      name: "Split selections on new line",
      hotkeys: MAP.split_selections_on_new_line,
      editorCallback: (editor) => splitSelectedTextOnNewLine(editor)
    }).id, this.addCommand({
      id: "select-multiple-word-instances",
      name: "Select multiple word instances",
      hotkeys: MAP.select_multiple_word_instances,
      editorCallback: (editor) => selectWordInstances(editor, this.settings.case_sensitive)
    }).id, this.addCommand({
      id: "select-all-word-instances",
      name: "Select all word instances",
      hotkeys: MAP.select_all_word_instances,
      editorCallback: (editor) => selectAllWordInstances(editor, this.settings.case_sensitive)
    }).id, this.addCommand({
      id: "expand-line-selections",
      name: "Expand line selections",
      hotkeys: MAP.expand_line_selections,
      editorCallback: (editor) => expandSelections(editor)
    }).id, this.addCommand({
      id: "split-selections-by-lines",
      name: "Split selections by lines",
      hotkeys: MAP.split_selections_by_lines,
      editorCallback: (editor) => splitSelectionsByLines(editor)
    }).id, this.addCommand({
      id: "trim-selections",
      name: "Trim selections",
      hotkeys: MAP.trim_selections,
      editorCallback: (editor) => replaceSelections(editor, (s) => s.trim())
    }).id, this.addCommand({
      id: "transform-from-to-snake-case",
      name: "Transform selections from / to Snakecase",
      hotkeys: MAP.transform_from_to_snakecase,
      editorCallback: (editor) => convertOneToOtherChars(editor, " ", "_")
    }).id, this.addCommand({
      id: "transform-from-to-kebab-case",
      name: "Transform selections from / to Kebabcase",
      hotkeys: MAP.transform_from_to_kebabcase,
      editorCallback: (editor) => convertOneToOtherChars(editor, " ", "-")
    }).id, this.addCommand({
      id: "encode-or-decode-uri",
      name: "Encode / Decode URI selections",
      hotkeys: MAP.encode_or_decode_uri,
      editorCallback: (editor) => convertURI(editor)
    }).id, this.addCommand({
      id: "transform-selections-to-lowercase",
      name: "Transform selections to Lowercase",
      hotkeys: MAP.transform_selections_to_lowercase,
      editorCallback: (editor) => replaceSelections(editor, (s) => s.toLowerCase())
    }).id, this.addCommand({
      id: "transform-selections-to-uppercase",
      name: "Transform selections to Uppercase",
      hotkeys: MAP.transform_selections_to_uppercase,
      editorCallback: (editor) => replaceSelections(editor, (s) => s.toUpperCase())
    }).id, this.addCommand({
      id: "transform-selections-to-titlecase",
      name: "Transform selections to Titlecase (Capitalize)",
      hotkeys: MAP.transform_selections_to_titlecase,
      editorCallback: (editor) => replaceSelections(editor, (s) => titleCase(s))
    }).id, this.addCommand({
      id: "toggle-case",
      name: "Toggle case (JetBrains)",
      hotkeys: MAP.toggle_case,
      editorCallback: (editor) => replaceSelections(editor, (str) => str === str.toLowerCase() ? str.toUpperCase() : str.toLowerCase())
    }).id, this.addCommand({
      id: "sort-selected-lines",
      name: "Sort selected lines",
      hotkeys: MAP.sort_selected_lines,
      editorCallback: (editor) => sortSelectedLines(editor)
    }).id, this.addCommand({
      id: "shuffle-selected-lines",
      name: "Shuffle selected lines",
      hotkeys: MAP.shuffle_selected_lines,
      editorCallback: (editor) => shuffleSelectedLines(editor, this.settings.shuffle_rounds_amount)
    }).id);
    this.command_ids = new Set(IDS);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var _fragment;
var DocumentFragmentBuilder = class {
  constructor() {
    __privateAdd(this, _fragment, void 0);
    __privateSet(this, _fragment, document.createDocumentFragment());
  }
  appendText(text) {
    __privateGet(this, _fragment).append(text);
    return this;
  }
  createElem(tag, o) {
    __privateGet(this, _fragment).createEl(tag, o);
    return this;
  }
  toFragment() {
    return __privateGet(this, _fragment);
  }
};
_fragment = new WeakMap();
var KeyshotsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Keyshots Settings" });
    containerEl.createEl("h2", { text: "\u2328\uFE0F Default keys" });
    new import_obsidian.Setting(containerEl).setName("IDE Keys Mapping").setDesc("Change default hotkeys based on IDE, that you are comfortable with. This does not overwrite your custom hotkeys!").setDesc(new DocumentFragmentBuilder().appendText("Change default hotkeys based on IDE, that you are comfortable with.").createElem("br").createElem("b", { text: "\u2757This does not overwrite your custom Keyshots hotkeys configuration!" }).toFragment()).addDropdown((cb) => cb.addOptions({
      "clear": "Clear (everything blank; default)",
      "vscode": "Visual Studio Code",
      "jetbrains": "JetBrains IDEs (IntelliJ IDEA, Pycharm, ... )",
      "visual_studio": "Microsoft Visual Studio",
      "keyshots": "Keyshots default hotkeys mappings"
    }).setValue(this.plugin.settings.ide_mappings).onChange(async (value) => {
      this.plugin.settings.ide_mappings = value;
      await this.plugin.loadCommands();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Keyshots hotkeys").setDesc(new DocumentFragmentBuilder().appendText("Sets default hotkeys for keyshots commands, that are not modified by IDE preset.").createElem("br").createElem("b", { text: "\u2757If you select clear preset, this setting will be ignored!" }).toFragment()).addToggle((cb) => cb.setValue(this.plugin.settings.keyshot_mappings).onChange(async (value) => {
      this.plugin.settings.keyshot_mappings = value;
      await this.plugin.loadCommands();
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u{1F527} Commands settings" });
    new import_obsidian.Setting(containerEl).setName("Case sensitivity").setDesc(new DocumentFragmentBuilder().appendText("Determines if Keyshots commands should be case sensitive. For toggling while editing text just simply use ").createElem("kbd", { text: " Ctrl + Alt + I " }).appendText(" hotkey if you are using default Keyshots binding!").toFragment()).addToggle((cb) => cb.setValue(this.plugin.settings.case_sensitive).onChange(async (value) => {
      this.plugin.settings.case_sensitive = value;
      await this.plugin.saveSettings();
    }));
    let slider;
    new import_obsidian.Setting(containerEl).setName("Shuffle rounds amount").setDesc(new DocumentFragmentBuilder().appendText("Number of rounds that will ").createElem("code", { text: "Shuffle selected lines" }).appendText(" command take. The more rounds it will take, the more random it will be!").toFragment()).addSlider((cb) => {
      slider = cb;
      slider.setValue(this.plugin.settings.shuffle_rounds_amount).setLimits(1, 50, 1).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.shuffle_rounds_amount = value;
        await this.plugin.saveSettings();
      });
    }).addButton((cb) => cb.setIcon("refresh-ccw").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.shuffle_rounds_amount = DEFAULT_SETTINGS.shuffle_rounds_amount;
      slider.setValue(DEFAULT_SETTINGS.shuffle_rounds_amount);
      await this.plugin.saveSettings();
    }));
  }
};
